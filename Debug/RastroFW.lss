
RastroFW.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800200  00000e3c  00000ed0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e3c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fe8  0080020c  0080020c  00000edc  2**0
                  ALLOC
  3 .stab         00003714  00000000  00000000  00000edc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001760  00000000  00000000  000045f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00005d50  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c1       	rjmp	.+738    	; 0x2e4 <__ctors_end>
   2:	00 00       	nop
   4:	0d c4       	rjmp	.+2074   	; 0x820 <__vector_1>
   6:	00 00       	nop
   8:	8c c1       	rjmp	.+792    	; 0x322 <__bad_interrupt>
   a:	00 00       	nop
   c:	8a c1       	rjmp	.+788    	; 0x322 <__bad_interrupt>
   e:	00 00       	nop
  10:	88 c1       	rjmp	.+784    	; 0x322 <__bad_interrupt>
  12:	00 00       	nop
  14:	86 c1       	rjmp	.+780    	; 0x322 <__bad_interrupt>
  16:	00 00       	nop
  18:	84 c1       	rjmp	.+776    	; 0x322 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	82 c1       	rjmp	.+772    	; 0x322 <__bad_interrupt>
  1e:	00 00       	nop
  20:	80 c1       	rjmp	.+768    	; 0x322 <__bad_interrupt>
  22:	00 00       	nop
  24:	7e c1       	rjmp	.+764    	; 0x322 <__bad_interrupt>
  26:	00 00       	nop
  28:	7c c1       	rjmp	.+760    	; 0x322 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	7a c1       	rjmp	.+756    	; 0x322 <__bad_interrupt>
  2e:	00 00       	nop
  30:	78 c1       	rjmp	.+752    	; 0x322 <__bad_interrupt>
  32:	00 00       	nop
  34:	76 c1       	rjmp	.+748    	; 0x322 <__bad_interrupt>
  36:	00 00       	nop
  38:	74 c1       	rjmp	.+744    	; 0x322 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	72 c1       	rjmp	.+740    	; 0x322 <__bad_interrupt>
  3e:	00 00       	nop
  40:	70 c1       	rjmp	.+736    	; 0x322 <__bad_interrupt>
  42:	00 00       	nop
  44:	6e c1       	rjmp	.+732    	; 0x322 <__bad_interrupt>
  46:	00 00       	nop
  48:	6c c1       	rjmp	.+728    	; 0x322 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	6a c1       	rjmp	.+724    	; 0x322 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3f c5       	rjmp	.+2686   	; 0xad0 <__vector_20>
  52:	00 00       	nop
  54:	9a c4       	rjmp	.+2356   	; 0x98a <__vector_21>
  56:	00 00       	nop
  58:	64 c1       	rjmp	.+712    	; 0x322 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	62 c1       	rjmp	.+708    	; 0x322 <__bad_interrupt>
  5e:	00 00       	nop
  60:	60 c1       	rjmp	.+704    	; 0x322 <__bad_interrupt>
  62:	00 00       	nop
  64:	5a c6       	rjmp	.+3252   	; 0xd1a <__vector_25>
  66:	00 00       	nop
  68:	8e c6       	rjmp	.+3356   	; 0xd86 <__vector_26>
  6a:	00 00       	nop
  6c:	5a c1       	rjmp	.+692    	; 0x322 <__bad_interrupt>
  6e:	00 00       	nop
  70:	58 c1       	rjmp	.+688    	; 0x322 <__bad_interrupt>
  72:	00 00       	nop
  74:	56 c1       	rjmp	.+684    	; 0x322 <__bad_interrupt>
  76:	00 00       	nop
  78:	54 c1       	rjmp	.+680    	; 0x322 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	52 c1       	rjmp	.+676    	; 0x322 <__bad_interrupt>
  7e:	00 00       	nop
  80:	50 c1       	rjmp	.+672    	; 0x322 <__bad_interrupt>
  82:	00 00       	nop
  84:	4e c1       	rjmp	.+668    	; 0x322 <__bad_interrupt>
  86:	00 00       	nop
  88:	4c c1       	rjmp	.+664    	; 0x322 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	4a c1       	rjmp	.+660    	; 0x322 <__bad_interrupt>
  8e:	00 00       	nop
  90:	48 c1       	rjmp	.+656    	; 0x322 <__bad_interrupt>
  92:	00 00       	nop
  94:	46 c1       	rjmp	.+652    	; 0x322 <__bad_interrupt>
  96:	00 00       	nop
  98:	44 c1       	rjmp	.+648    	; 0x322 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	42 c1       	rjmp	.+644    	; 0x322 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	40 c1       	rjmp	.+640    	; 0x322 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3e c1       	rjmp	.+636    	; 0x322 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3c c1       	rjmp	.+632    	; 0x322 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	3a c1       	rjmp	.+628    	; 0x322 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	38 c1       	rjmp	.+624    	; 0x322 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	36 c1       	rjmp	.+620    	; 0x322 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	34 c1       	rjmp	.+616    	; 0x322 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	32 c1       	rjmp	.+612    	; 0x322 <__bad_interrupt>
  be:	00 00       	nop
  c0:	30 c1       	rjmp	.+608    	; 0x322 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2e c1       	rjmp	.+604    	; 0x322 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2c c1       	rjmp	.+600    	; 0x322 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	2a c1       	rjmp	.+596    	; 0x322 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	28 c1       	rjmp	.+592    	; 0x322 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	26 c1       	rjmp	.+588    	; 0x322 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	24 c1       	rjmp	.+584    	; 0x322 <__bad_interrupt>
  da:	00 00       	nop
  dc:	22 c1       	rjmp	.+580    	; 0x322 <__bad_interrupt>
  de:	00 00       	nop
  e0:	20 c1       	rjmp	.+576    	; 0x322 <__bad_interrupt>
	...

000000e4 <_ZL9CRC16_TBL>:
  e4:	00 00 c1 c0 81 c1 40 01 01 c3 c0 03 80 02 41 c2     ......@.......A.
  f4:	01 c6 c0 06 80 07 41 c7 00 05 c1 c5 81 c4 40 04     ......A.......@.
 104:	01 cc c0 0c 80 0d 41 cd 00 0f c1 cf 81 ce 40 0e     ......A.......@.
 114:	00 0a c1 ca 81 cb 40 0b 01 c9 c0 09 80 08 41 c8     ......@.......A.
 124:	01 d8 c0 18 80 19 41 d9 00 1b c1 db 81 da 40 1a     ......A.......@.
 134:	00 1e c1 de 81 df 40 1f 01 dd c0 1d 80 1c 41 dc     ......@.......A.
 144:	00 14 c1 d4 81 d5 40 15 01 d7 c0 17 80 16 41 d6     ......@.......A.
 154:	01 d2 c0 12 80 13 41 d3 00 11 c1 d1 81 d0 40 10     ......A.......@.
 164:	01 f0 c0 30 80 31 41 f1 00 33 c1 f3 81 f2 40 32     ...0.1A..3....@2
 174:	00 36 c1 f6 81 f7 40 37 01 f5 c0 35 80 34 41 f4     .6....@7...5.4A.
 184:	00 3c c1 fc 81 fd 40 3d 01 ff c0 3f 80 3e 41 fe     .<....@=...?.>A.
 194:	01 fa c0 3a 80 3b 41 fb 00 39 c1 f9 81 f8 40 38     ...:.;A..9....@8
 1a4:	00 28 c1 e8 81 e9 40 29 01 eb c0 2b 80 2a 41 ea     .(....@)...+.*A.
 1b4:	01 ee c0 2e 80 2f 41 ef 00 2d c1 ed 81 ec 40 2c     ...../A..-....@,
 1c4:	01 e4 c0 24 80 25 41 e5 00 27 c1 e7 81 e6 40 26     ...$.%A..'....@&
 1d4:	00 22 c1 e2 81 e3 40 23 01 e1 c0 21 80 20 41 e0     ."....@#...!. A.
 1e4:	01 a0 c0 60 80 61 41 a1 00 63 c1 a3 81 a2 40 62     ...`.aA..c....@b
 1f4:	00 66 c1 a6 81 a7 40 67 01 a5 c0 65 80 64 41 a4     .f....@g...e.dA.
 204:	00 6c c1 ac 81 ad 40 6d 01 af c0 6f 80 6e 41 ae     .l....@m...o.nA.
 214:	01 aa c0 6a 80 6b 41 ab 00 69 c1 a9 81 a8 40 68     ...j.kA..i....@h
 224:	00 78 c1 b8 81 b9 40 79 01 bb c0 7b 80 7a 41 ba     .x....@y...{.zA.
 234:	01 be c0 7e 80 7f 41 bf 00 7d c1 bd 81 bc 40 7c     ...~..A..}....@|
 244:	01 b4 c0 74 80 75 41 b5 00 77 c1 b7 81 b6 40 76     ...t.uA..w....@v
 254:	00 72 c1 b2 81 b3 40 73 01 b1 c0 71 80 70 41 b0     .r....@s...q.pA.
 264:	00 50 c1 90 81 91 40 51 01 93 c0 53 80 52 41 92     .P....@Q...S.RA.
 274:	01 96 c0 56 80 57 41 97 00 55 c1 95 81 94 40 54     ...V.WA..U....@T
 284:	01 9c c0 5c 80 5d 41 9d 00 5f c1 9f 81 9e 40 5e     ...\.]A.._....@^
 294:	00 5a c1 9a 81 9b 40 5b 01 99 c0 59 80 58 41 98     .Z....@[...Y.XA.
 2a4:	01 88 c0 48 80 49 41 89 00 4b c1 8b 81 8a 40 4a     ...H.IA..K....@J
 2b4:	00 4e c1 8e 81 8f 40 4f 01 8d c0 4d 80 4c 41 8c     .N....@O...M.LA.
 2c4:	00 44 c1 84 81 85 40 45 01 87 c0 47 80 46 41 86     .D....@E...G.FA.
 2d4:	01 82 c0 42 80 43 41 83 00 41 c1 81 81 80 40 40     ...B.CA..A....@@

000002e4 <__ctors_end>:
 2e4:	11 24       	eor	r1, r1
 2e6:	1f be       	out	0x3f, r1	; 63
 2e8:	cf ef       	ldi	r28, 0xFF	; 255
 2ea:	d1 e2       	ldi	r29, 0x21	; 33
 2ec:	de bf       	out	0x3e, r29	; 62
 2ee:	cd bf       	out	0x3d, r28	; 61
 2f0:	00 e0       	ldi	r16, 0x00	; 0
 2f2:	0c bf       	out	0x3c, r16	; 60

000002f4 <__do_copy_data>:
 2f4:	12 e0       	ldi	r17, 0x02	; 2
 2f6:	a0 e0       	ldi	r26, 0x00	; 0
 2f8:	b2 e0       	ldi	r27, 0x02	; 2
 2fa:	ec e3       	ldi	r30, 0x3C	; 60
 2fc:	fe e0       	ldi	r31, 0x0E	; 14
 2fe:	00 e0       	ldi	r16, 0x00	; 0
 300:	0b bf       	out	0x3b, r16	; 59
 302:	02 c0       	rjmp	.+4      	; 0x308 <__do_copy_data+0x14>
 304:	07 90       	elpm	r0, Z+
 306:	0d 92       	st	X+, r0
 308:	ac 30       	cpi	r26, 0x0C	; 12
 30a:	b1 07       	cpc	r27, r17
 30c:	d9 f7       	brne	.-10     	; 0x304 <__do_copy_data+0x10>

0000030e <__do_clear_bss>:
 30e:	11 e1       	ldi	r17, 0x11	; 17
 310:	ac e0       	ldi	r26, 0x0C	; 12
 312:	b2 e0       	ldi	r27, 0x02	; 2
 314:	01 c0       	rjmp	.+2      	; 0x318 <.do_clear_bss_start>

00000316 <.do_clear_bss_loop>:
 316:	1d 92       	st	X+, r1

00000318 <.do_clear_bss_start>:
 318:	a4 3f       	cpi	r26, 0xF4	; 244
 31a:	b1 07       	cpc	r27, r17
 31c:	e1 f7       	brne	.-8      	; 0x316 <.do_clear_bss_loop>
 31e:	3f d2       	rcall	.+1150   	; 0x79e <main>
 320:	8b c5       	rjmp	.+2838   	; 0xe38 <_exit>

00000322 <__bad_interrupt>:
 322:	6e ce       	rjmp	.-804    	; 0x0 <__vectors>

00000324 <_ZN4Core8initCoreEv>:
volatile const char* nak = "NAK";
volatile const char* ack = "ACK";

volatile struct Settings settings;

void initCore() {
 324:	cf 93       	push	r28
 326:	df 93       	push	r29
 328:	cd b7       	in	r28, 0x3d	; 61
 32a:	de b7       	in	r29, 0x3e	; 62
	rxBuff = buffer[0];
 32c:	8d e0       	ldi	r24, 0x0D	; 13
 32e:	92 e0       	ldi	r25, 0x02	; 2
 330:	90 93 ae 11 	sts	0x11AE, r25
 334:	80 93 ad 11 	sts	0x11AD, r24
	wBuff = buffer[1];
 338:	8d ed       	ldi	r24, 0xDD	; 221
 33a:	99 e0       	ldi	r25, 0x09	; 9
 33c:	90 93 b0 11 	sts	0x11B0, r25
 340:	80 93 af 11 	sts	0x11AF, r24
	memset(wBuff, 0, BUFF_SIZE);
 344:	80 91 af 11 	lds	r24, 0x11AF
 348:	90 91 b0 11 	lds	r25, 0x11B0
 34c:	40 ed       	ldi	r20, 0xD0	; 208
 34e:	57 e0       	ldi	r21, 0x07	; 7
 350:	60 e0       	ldi	r22, 0x00	; 0
 352:	70 e0       	ldi	r23, 0x00	; 0
 354:	6a d5       	rcall	.+2772   	; 0xe2a <memset>
 356:	df 91       	pop	r29
}
 358:	cf 91       	pop	r28
 35a:	08 95       	ret

0000035c <_ZN4Core8loopCoreEv>:

void loopCore() {
 35c:	cf 93       	push	r28
 35e:	df 93       	push	r29
 360:	00 d0       	rcall	.+0      	; 0x362 <_ZN4Core8loopCoreEv+0x6>
 362:	cd b7       	in	r28, 0x3d	; 61
 364:	de b7       	in	r29, 0x3e	; 62
	uint16_t dataSize;
	if (Usart0::available()) {
 366:	16 d4       	rcall	.+2092   	; 0xb94 <_ZN6Usart09availableEv>
 368:	98 2f       	mov	r25, r24
 36a:	81 e0       	ldi	r24, 0x01	; 1
 36c:	99 23       	and	r25, r25
 36e:	09 f4       	brne	.+2      	; 0x372 <_ZN4Core8loopCoreEv+0x16>
 370:	80 e0       	ldi	r24, 0x00	; 0
 372:	88 23       	and	r24, r24
 374:	09 f4       	brne	.+2      	; 0x378 <_ZN4Core8loopCoreEv+0x1c>
 376:	73 c0       	rjmp	.+230    	; 0x45e <_ZN4Core8loopCoreEv+0x102>
 378:	1c d4       	rcall	.+2104   	; 0xbb2 <_ZN6Usart04peekEv>
		uint8_t inByte = Usart0::peek();
 37a:	89 83       	std	Y+1, r24	; 0x01
 37c:	89 81       	ldd	r24, Y+1	; 0x01
 37e:	88 2f       	mov	r24, r24
		switch(inByte) {
 380:	90 e0       	ldi	r25, 0x00	; 0
 382:	83 34       	cpi	r24, 0x43	; 67
 384:	91 05       	cpc	r25, r1
 386:	09 f4       	brne	.+2      	; 0x38a <_ZN4Core8loopCoreEv+0x2e>
 388:	3e c0       	rjmp	.+124    	; 0x406 <_ZN4Core8loopCoreEv+0xaa>
 38a:	8c 34       	cpi	r24, 0x4C	; 76
 38c:	91 05       	cpc	r25, r1
 38e:	09 f0       	breq	.+2      	; 0x392 <_ZN4Core8loopCoreEv+0x36>
 390:	64 c0       	rjmp	.+200    	; 0x45a <_ZN4Core8loopCoreEv+0xfe>
 392:	80 91 b4 11 	lds	r24, 0x11B4
		case 'L':
			dataSize = ((settings.lnLength + 7) >> 3) + 4;
 396:	90 91 b5 11 	lds	r25, 0x11B5
 39a:	07 96       	adiw	r24, 0x07	; 7
 39c:	95 95       	asr	r25
 39e:	87 95       	ror	r24
 3a0:	95 95       	asr	r25
 3a2:	87 95       	ror	r24
 3a4:	95 95       	asr	r25
 3a6:	87 95       	ror	r24
 3a8:	04 96       	adiw	r24, 0x04	; 4
 3aa:	9b 83       	std	Y+3, r25	; 0x03
 3ac:	8a 83       	std	Y+2, r24	; 0x02
 3ae:	80 91 ad 11 	lds	r24, 0x11AD
			if (Usart0::readBytes(rxBuff, dataSize) == dataSize &&
 3b2:	90 91 ae 11 	lds	r25, 0x11AE
 3b6:	2a 81       	ldd	r18, Y+2	; 0x02
 3b8:	3b 81       	ldd	r19, Y+3	; 0x03
 3ba:	b9 01       	movw	r22, r18
 3bc:	38 d4       	rcall	.+2160   	; 0xc2e <_ZN6Usart09readBytesEPhj>
 3be:	28 2f       	mov	r18, r24
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	8a 81       	ldd	r24, Y+2	; 0x02
 3c4:	9b 81       	ldd	r25, Y+3	; 0x03
 3c6:	28 17       	cp	r18, r24
					rxBuff[1] == 'N' &&
 3c8:	39 07       	cpc	r19, r25
 3ca:	a9 f4       	brne	.+42     	; 0x3f6 <_ZN4Core8loopCoreEv+0x9a>
 3cc:	80 91 ad 11 	lds	r24, 0x11AD
 3d0:	90 91 ae 11 	lds	r25, 0x11AE
 3d4:	01 96       	adiw	r24, 0x01	; 1
 3d6:	fc 01       	movw	r30, r24
 3d8:	80 81       	ld	r24, Z
 3da:	8e 34       	cpi	r24, 0x4E	; 78
 3dc:	61 f4       	brne	.+24     	; 0x3f6 <_ZN4Core8loopCoreEv+0x9a>
 3de:	80 91 ad 11 	lds	r24, 0x11AD
	if (Usart0::available()) {
		uint8_t inByte = Usart0::peek();
		switch(inByte) {
		case 'L':
			dataSize = ((settings.lnLength + 7) >> 3) + 4;
			if (Usart0::readBytes(rxBuff, dataSize) == dataSize &&
 3e2:	90 91 ae 11 	lds	r25, 0x11AE
					rxBuff[1] == 'N' &&
					checkCrc16(rxBuff, dataSize)) {
 3e6:	2a 81       	ldd	r18, Y+2	; 0x02
 3e8:	3b 81       	ldd	r19, Y+3	; 0x03
 3ea:	b9 01       	movw	r22, r18
 3ec:	5d d1       	rcall	.+698    	; 0x6a8 <_Z10checkCrc16PKhj>
 3ee:	88 23       	and	r24, r24
 3f0:	11 f0       	breq	.+4      	; 0x3f6 <_ZN4Core8loopCoreEv+0x9a>
 3f2:	81 e0       	ldi	r24, 0x01	; 1
 3f4:	01 c0       	rjmp	.+2      	; 0x3f8 <_ZN4Core8loopCoreEv+0x9c>
		uint8_t inByte = Usart0::peek();
		switch(inByte) {
		case 'L':
			dataSize = ((settings.lnLength + 7) >> 3) + 4;
			if (Usart0::readBytes(rxBuff, dataSize) == dataSize &&
					rxBuff[1] == 'N' &&
 3f6:	80 e0       	ldi	r24, 0x00	; 0
 3f8:	88 23       	and	r24, r24
 3fa:	19 f0       	breq	.+6      	; 0x402 <_ZN4Core8loopCoreEv+0xa6>
 3fc:	f1 d0       	rcall	.+482    	; 0x5e0 <_ZN4Core11swapBuffersEv>
 3fe:	35 d0       	rcall	.+106    	; 0x46a <_ZN4Core7sendACKEv>
	if (Usart0::available()) {
		uint8_t inByte = Usart0::peek();
		switch(inByte) {
		case 'L':
			dataSize = ((settings.lnLength + 7) >> 3) + 4;
			if (Usart0::readBytes(rxBuff, dataSize) == dataSize &&
 400:	2e c0       	rjmp	.+92     	; 0x45e <_ZN4Core8loopCoreEv+0x102>
 402:	40 d0       	rcall	.+128    	; 0x484 <_ZN4Core7sendNAKEv>
					rxBuff[1] == 'N' &&
					checkCrc16(rxBuff, dataSize)) {
				swapBuffers();
 404:	2c c0       	rjmp	.+88     	; 0x45e <_ZN4Core8loopCoreEv+0x102>
 406:	6b e0       	ldi	r22, 0x0B	; 11
				sendACK();
 408:	70 e0       	ldi	r23, 0x00	; 0
 40a:	82 eb       	ldi	r24, 0xB2	; 178
			}
			else {
				sendNAK();
			}
			break;
 40c:	91 e1       	ldi	r25, 0x11	; 17
					checkCrc16(rxBuff, dataSize)) {
				swapBuffers();
				sendACK();
			}
			else {
				sendNAK();
 40e:	0f d4       	rcall	.+2078   	; 0xc2e <_ZN6Usart09readBytesEPhj>
 410:	88 2f       	mov	r24, r24
			}
			break;
 412:	90 e0       	ldi	r25, 0x00	; 0
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
 414:	8b 30       	cpi	r24, 0x0B	; 11
 416:	91 05       	cpc	r25, r1
 418:	81 f4       	brne	.+32     	; 0x43a <_ZN4Core8loopCoreEv+0xde>
 41a:	80 91 b3 11 	lds	r24, 0x11B3
 41e:	86 34       	cpi	r24, 0x46	; 70
 420:	61 f4       	brne	.+24     	; 0x43a <_ZN4Core8loopCoreEv+0xde>
 422:	6b e0       	ldi	r22, 0x0B	; 11
					settings.header[1] == 'F' &&
					checkCrc16((uint8_t*)&settings, sizeof(settings)) &&
 424:	70 e0       	ldi	r23, 0x00	; 0
 426:	82 eb       	ldi	r24, 0xB2	; 178
 428:	91 e1       	ldi	r25, 0x11	; 17
				sendNAK();
			}
			break;
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
					settings.header[1] == 'F' &&
 42a:	3e d1       	rcall	.+636    	; 0x6a8 <_Z10checkCrc16PKhj>
 42c:	88 23       	and	r24, r24
			else {
				sendNAK();
			}
			break;
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
 42e:	29 f0       	breq	.+10     	; 0x43a <_ZN4Core8loopCoreEv+0xde>
 430:	f6 d0       	rcall	.+492    	; 0x61e <_ZN4Core14verifySettingsEv>
					settings.header[1] == 'F' &&
					checkCrc16((uint8_t*)&settings, sizeof(settings)) &&
 432:	88 23       	and	r24, r24
 434:	11 f0       	breq	.+4      	; 0x43a <_ZN4Core8loopCoreEv+0xde>
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	01 c0       	rjmp	.+2      	; 0x43c <_ZN4Core8loopCoreEv+0xe0>
 43a:	80 e0       	ldi	r24, 0x00	; 0
 43c:	88 23       	and	r24, r24
				sendNAK();
			}
			break;
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
					settings.header[1] == 'F' &&
 43e:	59 f0       	breq	.+22     	; 0x456 <_ZN4Core8loopCoreEv+0xfa>
 440:	e2 d1       	rcall	.+964    	; 0x806 <_ZN8Ptracker7setZeroEv>
					checkCrc16((uint8_t*)&settings, sizeof(settings)) &&
					verifySettings()) {
 442:	81 e0       	ldi	r24, 0x01	; 1
 444:	80 93 b1 11 	sts	0x11B1, r24
			}
			break;
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
					settings.header[1] == 'F' &&
					checkCrc16((uint8_t*)&settings, sizeof(settings)) &&
 448:	80 91 b8 11 	lds	r24, 0x11B8
 44c:	90 91 b9 11 	lds	r25, 0x11B9
			else {
				sendNAK();
			}
			break;
		case 'C':
			if (Usart0::readBytes((uint8_t*)&settings, sizeof(settings)) == sizeof(settings) &&
 450:	16 d3       	rcall	.+1580   	; 0xa7e <_ZN6Timer116setPulseDurationEi>
 452:	0b d0       	rcall	.+22     	; 0x46a <_ZN4Core7sendACKEv>
					settings.header[1] == 'F' &&
					checkCrc16((uint8_t*)&settings, sizeof(settings)) &&
					verifySettings()) {
				Ptracker::setZero();
 454:	04 c0       	rjmp	.+8      	; 0x45e <_ZN4Core8loopCoreEv+0x102>
 456:	16 d0       	rcall	.+44     	; 0x484 <_ZN4Core7sendNAKEv>
				isEnabled = 1;
 458:	02 c0       	rjmp	.+4      	; 0x45e <_ZN4Core8loopCoreEv+0x102>
 45a:	c5 d3       	rcall	.+1930   	; 0xbe6 <_ZN6Usart04readEv>
 45c:	00 00       	nop
				Timer1::setPulseDuration(settings.expTime);
 45e:	0f 90       	pop	r0
 460:	0f 90       	pop	r0
 462:	0f 90       	pop	r0
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	08 95       	ret

0000046a <_ZN4Core7sendACKEv>:
			break;
		}
	}
}

inline void sendACK() {
 46a:	cf 93       	push	r28
 46c:	df 93       	push	r29
 46e:	cd b7       	in	r28, 0x3d	; 61
 470:	de b7       	in	r29, 0x3e	; 62
	Usart0::write((uint8_t*)ack, 3);
 472:	80 91 02 02 	lds	r24, 0x0202
 476:	90 91 03 02 	lds	r25, 0x0203
 47a:	63 e0       	ldi	r22, 0x03	; 3
 47c:	2a d4       	rcall	.+2132   	; 0xcd2 <_ZN6Usart05writeEPKhh>
 47e:	df 91       	pop	r29
}
 480:	cf 91       	pop	r28
 482:	08 95       	ret

00000484 <_ZN4Core7sendNAKEv>:

inline void sendNAK() {
 484:	cf 93       	push	r28
 486:	df 93       	push	r29
 488:	cd b7       	in	r28, 0x3d	; 61
 48a:	de b7       	in	r29, 0x3e	; 62
	Usart0::write((uint8_t*)nak, 3);
 48c:	80 91 00 02 	lds	r24, 0x0200
 490:	90 91 01 02 	lds	r25, 0x0201
 494:	63 e0       	ldi	r22, 0x03	; 3
 496:	1d d4       	rcall	.+2106   	; 0xcd2 <_ZN6Usart05writeEPKhh>
 498:	df 91       	pop	r29
}
 49a:	cf 91       	pop	r28
 49c:	08 95       	ret

0000049e <_ZN4Core12onDirChangedEh>:

void onDirChanged(uint8_t dir) {
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	1f 92       	push	r1
 4a4:	cd b7       	in	r28, 0x3d	; 61
 4a6:	de b7       	in	r29, 0x3e	; 62
 4a8:	89 83       	std	Y+1, r24	; 0x01
	if (settings.mode){
 4aa:	90 91 ba 11 	lds	r25, 0x11BA
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	99 23       	and	r25, r25
 4b2:	09 f4       	brne	.+2      	; 0x4b6 <_ZN4Core12onDirChangedEh+0x18>
 4b4:	80 e0       	ldi	r24, 0x00	; 0
 4b6:	88 23       	and	r24, r24
 4b8:	41 f0       	breq	.+16     	; 0x4ca <_ZN4Core12onDirChangedEh+0x2c>
		isEnabled = !dir;
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	99 81       	ldd	r25, Y+1	; 0x01
 4be:	99 23       	and	r25, r25
 4c0:	09 f0       	breq	.+2      	; 0x4c4 <_ZN4Core12onDirChangedEh+0x26>
 4c2:	80 e0       	ldi	r24, 0x00	; 0
 4c4:	80 93 b1 11 	sts	0x11B1, r24
 4c8:	03 c0       	rjmp	.+6      	; 0x4d0 <_ZN4Core12onDirChangedEh+0x32>
	}
	else {
		isEnabled = 1;
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	80 93 b1 11 	sts	0x11B1, r24
	}
}
 4d0:	0f 90       	pop	r0
 4d2:	df 91       	pop	r29
 4d4:	cf 91       	pop	r28
 4d6:	08 95       	ret

000004d8 <_ZN4Core17onPositionChangedEi>:

void onPositionChanged(int16_t xPos) {
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	1f 92       	push	r1
 4de:	1f 92       	push	r1
 4e0:	cd b7       	in	r28, 0x3d	; 61
 4e2:	de b7       	in	r29, 0x3e	; 62
 4e4:	9a 83       	std	Y+2, r25	; 0x02
 4e6:	89 83       	std	Y+1, r24	; 0x01
	if (isEnabled && computeLaserState(xPos)) {
 4e8:	80 91 b1 11 	lds	r24, 0x11B1
 4ec:	88 23       	and	r24, r24
 4ee:	39 f0       	breq	.+14     	; 0x4fe <_ZN4Core17onPositionChangedEi+0x26>
 4f0:	89 81       	ldd	r24, Y+1	; 0x01
 4f2:	9a 81       	ldd	r25, Y+2	; 0x02
 4f4:	0d d0       	rcall	.+26     	; 0x510 <_ZN4Core17computeLaserStateEi>
 4f6:	88 23       	and	r24, r24
 4f8:	11 f0       	breq	.+4      	; 0x4fe <_ZN4Core17onPositionChangedEi+0x26>
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	01 c0       	rjmp	.+2      	; 0x500 <_ZN4Core17onPositionChangedEi+0x28>
 4fe:	80 e0       	ldi	r24, 0x00	; 0
 500:	88 23       	and	r24, r24
 502:	09 f0       	breq	.+2      	; 0x506 <_ZN4Core17onPositionChangedEi+0x2e>
 504:	d0 d2       	rcall	.+1440   	; 0xaa6 <_ZN6Timer15pulseEv>
		Timer1::pulse();
 506:	0f 90       	pop	r0
 508:	0f 90       	pop	r0
	}
}
 50a:	df 91       	pop	r29
 50c:	cf 91       	pop	r28
 50e:	08 95       	ret

00000510 <_ZN4Core17computeLaserStateEi>:

inline uint8_t computeLaserState(int16_t xPos) {
 510:	cf 93       	push	r28
 512:	df 93       	push	r29
 514:	1f 92       	push	r1
 516:	1f 92       	push	r1
 518:	cd b7       	in	r28, 0x3d	; 61
 51a:	de b7       	in	r29, 0x3e	; 62
 51c:	9a 83       	std	Y+2, r25	; 0x02
 51e:	89 83       	std	Y+1, r24	; 0x01
  if ((xPos < settings.offset) || (xPos >= settings.offset + settings.lnLength)) {
 520:	20 91 b6 11 	lds	r18, 0x11B6
 524:	30 91 b7 11 	lds	r19, 0x11B7
 528:	89 81       	ldd	r24, Y+1	; 0x01
 52a:	9a 81       	ldd	r25, Y+2	; 0x02
 52c:	82 17       	cp	r24, r18
 52e:	93 07       	cpc	r25, r19
 530:	7c f0       	brlt	.+30     	; 0x550 <_ZN4Core17computeLaserStateEi+0x40>
 532:	20 91 b6 11 	lds	r18, 0x11B6
 536:	30 91 b7 11 	lds	r19, 0x11B7
 53a:	80 91 b4 11 	lds	r24, 0x11B4
 53e:	90 91 b5 11 	lds	r25, 0x11B5
 542:	28 0f       	add	r18, r24
 544:	39 1f       	adc	r19, r25
 546:	89 81       	ldd	r24, Y+1	; 0x01
 548:	9a 81       	ldd	r25, Y+2	; 0x02
 54a:	82 17       	cp	r24, r18
 54c:	93 07       	cpc	r25, r19
 54e:	14 f0       	brlt	.+4      	; 0x554 <_ZN4Core17computeLaserStateEi+0x44>
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	01 c0       	rjmp	.+2      	; 0x556 <_ZN4Core17computeLaserStateEi+0x46>
 554:	80 e0       	ldi	r24, 0x00	; 0
 556:	88 23       	and	r24, r24
 558:	19 f0       	breq	.+6      	; 0x560 <_ZN4Core17computeLaserStateEi+0x50>
    return defaultLaserState;
 55a:	80 91 0c 02 	lds	r24, 0x020C
 55e:	0b c0       	rjmp	.+22     	; 0x576 <_ZN4Core17computeLaserStateEi+0x66>
  }
  return takeBitFromBuffer(xPos - settings.offset);
 560:	80 91 b6 11 	lds	r24, 0x11B6
 564:	90 91 b7 11 	lds	r25, 0x11B7
 568:	29 81       	ldd	r18, Y+1	; 0x01
 56a:	3a 81       	ldd	r19, Y+2	; 0x02
 56c:	a9 01       	movw	r20, r18
 56e:	48 1b       	sub	r20, r24
 570:	59 0b       	sbc	r21, r25
 572:	ca 01       	movw	r24, r20
 574:	05 d0       	rcall	.+10     	; 0x580 <_ZN4Core17takeBitFromBufferEi>
 576:	0f 90       	pop	r0
}
 578:	0f 90       	pop	r0
 57a:	df 91       	pop	r29
 57c:	cf 91       	pop	r28
 57e:	08 95       	ret

00000580 <_ZN4Core17takeBitFromBufferEi>:


inline uint8_t takeBitFromBuffer(int16_t idx) {
 580:	cf 93       	push	r28
 582:	df 93       	push	r29
 584:	00 d0       	rcall	.+0      	; 0x586 <_ZN4Core17takeBitFromBufferEi+0x6>
 586:	1f 92       	push	r1
 588:	cd b7       	in	r28, 0x3d	; 61
 58a:	de b7       	in	r29, 0x3e	; 62
 58c:	9c 83       	std	Y+4, r25	; 0x04
 58e:	8b 83       	std	Y+3, r24	; 0x03
  uint8_t shift = ((uint8_t)idx) & 7; //three LSBs
 590:	8b 81       	ldd	r24, Y+3	; 0x03
 592:	87 70       	andi	r24, 0x07	; 7
 594:	89 83       	std	Y+1, r24	; 0x01
  uint8_t dbyte = wBuff[idx >> 3];
 596:	20 91 af 11 	lds	r18, 0x11AF
 59a:	30 91 b0 11 	lds	r19, 0x11B0
 59e:	8b 81       	ldd	r24, Y+3	; 0x03
 5a0:	9c 81       	ldd	r25, Y+4	; 0x04
 5a2:	95 95       	asr	r25
 5a4:	87 95       	ror	r24
 5a6:	95 95       	asr	r25
 5a8:	87 95       	ror	r24
 5aa:	95 95       	asr	r25
 5ac:	87 95       	ror	r24
 5ae:	82 0f       	add	r24, r18
 5b0:	93 1f       	adc	r25, r19
 5b2:	fc 01       	movw	r30, r24
 5b4:	80 81       	ld	r24, Z
 5b6:	8a 83       	std	Y+2, r24	; 0x02
  return (dbyte >> shift) & 1;
 5b8:	8a 81       	ldd	r24, Y+2	; 0x02
 5ba:	88 2f       	mov	r24, r24
 5bc:	90 e0       	ldi	r25, 0x00	; 0
 5be:	29 81       	ldd	r18, Y+1	; 0x01
 5c0:	22 2f       	mov	r18, r18
 5c2:	30 e0       	ldi	r19, 0x00	; 0
 5c4:	02 2e       	mov	r0, r18
 5c6:	02 c0       	rjmp	.+4      	; 0x5cc <_ZN4Core17takeBitFromBufferEi+0x4c>
 5c8:	95 95       	asr	r25
 5ca:	87 95       	ror	r24
 5cc:	0a 94       	dec	r0
 5ce:	e2 f7       	brpl	.-8      	; 0x5c8 <_ZN4Core17takeBitFromBufferEi+0x48>
 5d0:	81 70       	andi	r24, 0x01	; 1
}
 5d2:	0f 90       	pop	r0
 5d4:	0f 90       	pop	r0
 5d6:	0f 90       	pop	r0
 5d8:	0f 90       	pop	r0
 5da:	df 91       	pop	r29
 5dc:	cf 91       	pop	r28
 5de:	08 95       	ret

000005e0 <_ZN4Core11swapBuffersEv>:

inline void swapBuffers() {
 5e0:	cf 93       	push	r28
 5e2:	df 93       	push	r29
 5e4:	1f 92       	push	r1
 5e6:	1f 92       	push	r1
 5e8:	cd b7       	in	r28, 0x3d	; 61
 5ea:	de b7       	in	r29, 0x3e	; 62
	uint8_t *t = rxBuff;
 5ec:	80 91 ad 11 	lds	r24, 0x11AD
 5f0:	90 91 ae 11 	lds	r25, 0x11AE
 5f4:	9a 83       	std	Y+2, r25	; 0x02
 5f6:	89 83       	std	Y+1, r24	; 0x01
	rxBuff = wBuff;
 5f8:	80 91 af 11 	lds	r24, 0x11AF
 5fc:	90 91 b0 11 	lds	r25, 0x11B0
 600:	90 93 ae 11 	sts	0x11AE, r25
 604:	80 93 ad 11 	sts	0x11AD, r24
	wBuff = t;
 608:	89 81       	ldd	r24, Y+1	; 0x01
 60a:	9a 81       	ldd	r25, Y+2	; 0x02
 60c:	90 93 b0 11 	sts	0x11B0, r25
 610:	80 93 af 11 	sts	0x11AF, r24
}
 614:	0f 90       	pop	r0
 616:	0f 90       	pop	r0
 618:	df 91       	pop	r29
 61a:	cf 91       	pop	r28
 61c:	08 95       	ret

0000061e <_ZN4Core14verifySettingsEv>:

uint8_t verifySettings() {
 61e:	cf 93       	push	r28
 620:	df 93       	push	r29
 622:	cd b7       	in	r28, 0x3d	; 61
 624:	de b7       	in	r29, 0x3e	; 62
	if (settings.lnLength > BUFF_SIZE * 8 ||
 626:	80 91 b4 11 	lds	r24, 0x11B4
 62a:	90 91 b5 11 	lds	r25, 0x11B5
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
			settings.offset < 0 ||
			settings.expTime > MAX_EXP_TIME ||
 62e:	81 38       	cpi	r24, 0x81	; 129
 630:	2e e3       	ldi	r18, 0x3E	; 62
 632:	92 07       	cpc	r25, r18
 634:	14 f5       	brge	.+68     	; 0x67a <_ZN4Core14verifySettingsEv+0x5c>
	wBuff = t;
}

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
			settings.lnLength < 0 ||
 636:	80 91 b4 11 	lds	r24, 0x11B4
 63a:	90 91 b5 11 	lds	r25, 0x11B5
	rxBuff = wBuff;
	wBuff = t;
}

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
 63e:	99 23       	and	r25, r25
 640:	e4 f0       	brlt	.+56     	; 0x67a <_ZN4Core14verifySettingsEv+0x5c>
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
 642:	80 91 b6 11 	lds	r24, 0x11B6
 646:	90 91 b7 11 	lds	r25, 0x11B7
	wBuff = t;
}

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
			settings.lnLength < 0 ||
 64a:	81 30       	cpi	r24, 0x01	; 1
 64c:	20 e1       	ldi	r18, 0x10	; 16
 64e:	92 07       	cpc	r25, r18
 650:	a4 f4       	brge	.+40     	; 0x67a <_ZN4Core14verifySettingsEv+0x5c>
			settings.offset > MAX_OFFSET ||
			settings.offset < 0 ||
 652:	80 91 b6 11 	lds	r24, 0x11B6
 656:	90 91 b7 11 	lds	r25, 0x11B7
}

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
 65a:	99 23       	and	r25, r25
 65c:	74 f0       	brlt	.+28     	; 0x67a <_ZN4Core14verifySettingsEv+0x5c>
			settings.offset < 0 ||
			settings.expTime > MAX_EXP_TIME ||
 65e:	80 91 b8 11 	lds	r24, 0x11B8
 662:	90 91 b9 11 	lds	r25, 0x11B9

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
			settings.offset < 0 ||
 666:	81 32       	cpi	r24, 0x21	; 33
 668:	2e e4       	ldi	r18, 0x4E	; 78
 66a:	92 07       	cpc	r25, r18
 66c:	34 f4       	brge	.+12     	; 0x67a <_ZN4Core14verifySettingsEv+0x5c>
			settings.expTime > MAX_EXP_TIME ||
			settings.expTime < 0) {
 66e:	80 91 b8 11 	lds	r24, 0x11B8
 672:	90 91 b9 11 	lds	r25, 0x11B9
uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
			settings.offset < 0 ||
			settings.expTime > MAX_EXP_TIME ||
 676:	99 23       	and	r25, r25
 678:	14 f4       	brge	.+4      	; 0x67e <_ZN4Core14verifySettingsEv+0x60>
 67a:	81 e0       	ldi	r24, 0x01	; 1
 67c:	01 c0       	rjmp	.+2      	; 0x680 <_ZN4Core14verifySettingsEv+0x62>
 67e:	80 e0       	ldi	r24, 0x00	; 0
	rxBuff = wBuff;
	wBuff = t;
}

uint8_t verifySettings() {
	if (settings.lnLength > BUFF_SIZE * 8 ||
 680:	88 23       	and	r24, r24
 682:	71 f0       	breq	.+28     	; 0x6a0 <_ZN4Core14verifySettingsEv+0x82>
			settings.lnLength < 0 ||
			settings.offset > MAX_OFFSET ||
			settings.offset < 0 ||
			settings.expTime > MAX_EXP_TIME ||
			settings.expTime < 0) {
		settings.lnLength = 0;
 684:	10 92 b5 11 	sts	0x11B5, r1
 688:	10 92 b4 11 	sts	0x11B4, r1
		settings.offset = 0;
 68c:	10 92 b7 11 	sts	0x11B7, r1
 690:	10 92 b6 11 	sts	0x11B6, r1
		settings.expTime = 0;
 694:	10 92 b9 11 	sts	0x11B9, r1
 698:	10 92 b8 11 	sts	0x11B8, r1
		return 0;
 69c:	80 e0       	ldi	r24, 0x00	; 0
 69e:	01 c0       	rjmp	.+2      	; 0x6a2 <_ZN4Core14verifySettingsEv+0x84>
	}
	return 1;
 6a0:	81 e0       	ldi	r24, 0x01	; 1
}
 6a2:	df 91       	pop	r29
 6a4:	cf 91       	pop	r28
 6a6:	08 95       	ret

000006a8 <_Z10checkCrc16PKhj>:
        0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
        0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

uint8_t checkCrc16(const uint8_t* data, uint16_t cnt) {
 6a8:	cf 93       	push	r28
 6aa:	df 93       	push	r29
 6ac:	cd b7       	in	r28, 0x3d	; 61
 6ae:	de b7       	in	r29, 0x3e	; 62
 6b0:	2c 97       	sbiw	r28, 0x0c	; 12
 6b2:	0f b6       	in	r0, 0x3f	; 63
 6b4:	f8 94       	cli
 6b6:	de bf       	out	0x3e, r29	; 62
 6b8:	0f be       	out	0x3f, r0	; 63
 6ba:	cd bf       	out	0x3d, r28	; 61
 6bc:	9a 87       	std	Y+10, r25	; 0x0a
 6be:	89 87       	std	Y+9, r24	; 0x09
 6c0:	7c 87       	std	Y+12, r23	; 0x0c
 6c2:	6b 87       	std	Y+11, r22	; 0x0b
	uint16_t res;
	res = 0;
 6c4:	1a 82       	std	Y+2, r1	; 0x02
 6c6:	19 82       	std	Y+1, r1	; 0x01
	for (uint16_t i = 0; i < cnt - 2; i++) {
 6c8:	1c 82       	std	Y+4, r1	; 0x04
 6ca:	1b 82       	std	Y+3, r1	; 0x03
 6cc:	2e c0       	rjmp	.+92     	; 0x72a <_Z10checkCrc16PKhj+0x82>
		res = pgm_read_word_near(&CRC16_TBL[data[i] ^ (res & 0xFF)]) ^ (res >> 8);
 6ce:	29 85       	ldd	r18, Y+9	; 0x09
 6d0:	3a 85       	ldd	r19, Y+10	; 0x0a
 6d2:	8b 81       	ldd	r24, Y+3	; 0x03
 6d4:	9c 81       	ldd	r25, Y+4	; 0x04
 6d6:	82 0f       	add	r24, r18
 6d8:	93 1f       	adc	r25, r19
 6da:	fc 01       	movw	r30, r24
 6dc:	80 81       	ld	r24, Z
 6de:	28 2f       	mov	r18, r24
 6e0:	30 e0       	ldi	r19, 0x00	; 0
 6e2:	89 81       	ldd	r24, Y+1	; 0x01
 6e4:	9a 81       	ldd	r25, Y+2	; 0x02
 6e6:	99 27       	eor	r25, r25
 6e8:	82 27       	eor	r24, r18
 6ea:	93 27       	eor	r25, r19
 6ec:	88 0f       	add	r24, r24
 6ee:	99 1f       	adc	r25, r25
 6f0:	8c 51       	subi	r24, 0x1C	; 28
 6f2:	9f 4f       	sbci	r25, 0xFF	; 255
 6f4:	9e 83       	std	Y+6, r25	; 0x06
 6f6:	8d 83       	std	Y+5, r24	; 0x05
 6f8:	8d 81       	ldd	r24, Y+5	; 0x05
 6fa:	9e 81       	ldd	r25, Y+6	; 0x06
 6fc:	fc 01       	movw	r30, r24
 6fe:	25 91       	lpm	r18, Z+
 700:	34 91       	lpm	r19, Z
 702:	cf 01       	movw	r24, r30
 704:	38 87       	std	Y+8, r19	; 0x08
 706:	2f 83       	std	Y+7, r18	; 0x07
 708:	9e 83       	std	Y+6, r25	; 0x06
 70a:	8d 83       	std	Y+5, r24	; 0x05
 70c:	2f 81       	ldd	r18, Y+7	; 0x07
 70e:	38 85       	ldd	r19, Y+8	; 0x08
 710:	89 81       	ldd	r24, Y+1	; 0x01
 712:	9a 81       	ldd	r25, Y+2	; 0x02
 714:	89 2f       	mov	r24, r25
 716:	99 27       	eor	r25, r25
 718:	82 27       	eor	r24, r18
 71a:	93 27       	eor	r25, r19
 71c:	9a 83       	std	Y+2, r25	; 0x02
 71e:	89 83       	std	Y+1, r24	; 0x01
};

uint8_t checkCrc16(const uint8_t* data, uint16_t cnt) {
	uint16_t res;
	res = 0;
	for (uint16_t i = 0; i < cnt - 2; i++) {
 720:	8b 81       	ldd	r24, Y+3	; 0x03
 722:	9c 81       	ldd	r25, Y+4	; 0x04
 724:	01 96       	adiw	r24, 0x01	; 1
 726:	9c 83       	std	Y+4, r25	; 0x04
 728:	8b 83       	std	Y+3, r24	; 0x03
 72a:	8b 85       	ldd	r24, Y+11	; 0x0b
 72c:	9c 85       	ldd	r25, Y+12	; 0x0c
 72e:	9c 01       	movw	r18, r24
 730:	22 50       	subi	r18, 0x02	; 2
 732:	31 09       	sbc	r19, r1
 734:	8b 81       	ldd	r24, Y+3	; 0x03
 736:	9c 81       	ldd	r25, Y+4	; 0x04
 738:	82 17       	cp	r24, r18
 73a:	93 07       	cpc	r25, r19
 73c:	40 f2       	brcs	.-112    	; 0x6ce <_Z10checkCrc16PKhj+0x26>
		res = pgm_read_word_near(&CRC16_TBL[data[i] ^ (res & 0xFF)]) ^ (res >> 8);
	}
	res ^= ((uint16_t)data[cnt-1] << 8) + data[cnt-2];
 73e:	8b 85       	ldd	r24, Y+11	; 0x0b
 740:	9c 85       	ldd	r25, Y+12	; 0x0c
 742:	01 97       	sbiw	r24, 0x01	; 1
 744:	29 85       	ldd	r18, Y+9	; 0x09
 746:	3a 85       	ldd	r19, Y+10	; 0x0a
 748:	82 0f       	add	r24, r18
 74a:	93 1f       	adc	r25, r19
 74c:	fc 01       	movw	r30, r24
 74e:	80 81       	ld	r24, Z
 750:	88 2f       	mov	r24, r24
 752:	90 e0       	ldi	r25, 0x00	; 0
 754:	38 2f       	mov	r19, r24
 756:	22 27       	eor	r18, r18
 758:	8b 85       	ldd	r24, Y+11	; 0x0b
 75a:	9c 85       	ldd	r25, Y+12	; 0x0c
 75c:	02 97       	sbiw	r24, 0x02	; 2
 75e:	49 85       	ldd	r20, Y+9	; 0x09
 760:	5a 85       	ldd	r21, Y+10	; 0x0a
 762:	84 0f       	add	r24, r20
 764:	95 1f       	adc	r25, r21
 766:	fc 01       	movw	r30, r24
 768:	80 81       	ld	r24, Z
 76a:	88 2f       	mov	r24, r24
 76c:	90 e0       	ldi	r25, 0x00	; 0
 76e:	82 0f       	add	r24, r18
 770:	93 1f       	adc	r25, r19
 772:	29 81       	ldd	r18, Y+1	; 0x01
 774:	3a 81       	ldd	r19, Y+2	; 0x02
 776:	82 27       	eor	r24, r18
 778:	93 27       	eor	r25, r19
 77a:	9a 83       	std	Y+2, r25	; 0x02
 77c:	89 83       	std	Y+1, r24	; 0x01
	return !res;
 77e:	21 e0       	ldi	r18, 0x01	; 1
 780:	89 81       	ldd	r24, Y+1	; 0x01
 782:	9a 81       	ldd	r25, Y+2	; 0x02
 784:	00 97       	sbiw	r24, 0x00	; 0
 786:	09 f0       	breq	.+2      	; 0x78a <_Z10checkCrc16PKhj+0xe2>
 788:	20 e0       	ldi	r18, 0x00	; 0
 78a:	82 2f       	mov	r24, r18
}
 78c:	2c 96       	adiw	r28, 0x0c	; 12
 78e:	0f b6       	in	r0, 0x3f	; 63
 790:	f8 94       	cli
 792:	de bf       	out	0x3e, r29	; 62
 794:	0f be       	out	0x3f, r0	; 63
 796:	cd bf       	out	0x3d, r28	; 61
 798:	df 91       	pop	r29
 79a:	cf 91       	pop	r28
 79c:	08 95       	ret

0000079e <main>:
#include "../inc/timer0.h"
#include "../inc/timer1.h"
#include "../inc/ptracker.h"
#include "../inc/core.h"

int main() {
 79e:	cf 93       	push	r28
 7a0:	df 93       	push	r29
 7a2:	cd b7       	in	r28, 0x3d	; 61
 7a4:	de b7       	in	r29, 0x3e	; 62
	cli();
 7a6:	f8 94       	cli
	Usart0::initUsart();
 7a8:	c0 d1       	rcall	.+896    	; 0xb2a <_ZN6Usart09initUsartEv>
 7aa:	c7 d0       	rcall	.+398    	; 0x93a <_ZN6Timer09initTimerEv>
	Timer0::initTimer();
 7ac:	89 e0       	ldi	r24, 0x09	; 9
 7ae:	97 e0       	ldi	r25, 0x07	; 7
	Timer0::timerHandlers[0] = Usart0::onTimerTick;
 7b0:	90 93 c5 11 	sts	0x11C5, r25
 7b4:	80 93 c4 11 	sts	0x11C4, r24
 7b8:	8f e4       	ldi	r24, 0x4F	; 79
 7ba:	92 e0       	ldi	r25, 0x02	; 2
	Ptracker::onDirChangedPtr = Core::onDirChanged;
 7bc:	90 93 be 11 	sts	0x11BE, r25
 7c0:	80 93 bd 11 	sts	0x11BD, r24
 7c4:	8c e6       	ldi	r24, 0x6C	; 108
 7c6:	92 e0       	ldi	r25, 0x02	; 2
	Ptracker::onPositionChangedPtr = Core::onPositionChanged;
 7c8:	90 93 c0 11 	sts	0x11C0, r25
 7cc:	80 93 bf 11 	sts	0x11BF, r24
 7d0:	05 d0       	rcall	.+10     	; 0x7dc <_ZN8Ptracker11initTrackerEv>
 7d2:	2a d1       	rcall	.+596    	; 0xa28 <_ZN6Timer19initTimerEv>
	Ptracker::initTracker();
 7d4:	a7 dd       	rcall	.-1202   	; 0x324 <_ZN4Core8initCoreEv>
 7d6:	78 94       	sei
	Timer1::initTimer();
 7d8:	c1 dd       	rcall	.-1150   	; 0x35c <_ZN4Core8loopCoreEv>
 7da:	fe cf       	rjmp	.-4      	; 0x7d8 <main+0x3a>

000007dc <_ZN8Ptracker11initTrackerEv>:
void (*onDirChangedPtr)(uint8_t);
void (*onPositionChangedPtr)(int16_t);
static volatile int16_t xPos;
static volatile uint8_t dir;

void initTracker() {
 7dc:	cf 93       	push	r28
 7de:	df 93       	push	r29
 7e0:	cd b7       	in	r28, 0x3d	; 61
 7e2:	de b7       	in	r29, 0x3e	; 62
	EICRA = (1<<ISC01) | (1<<ISC00);	// Interrupt on the rising edge
 7e4:	89 e6       	ldi	r24, 0x69	; 105
 7e6:	90 e0       	ldi	r25, 0x00	; 0
 7e8:	23 e0       	ldi	r18, 0x03	; 3
 7ea:	fc 01       	movw	r30, r24
 7ec:	20 83       	st	Z, r18
	EICRB = 0;
 7ee:	8a e6       	ldi	r24, 0x6A	; 106
 7f0:	90 e0       	ldi	r25, 0x00	; 0
 7f2:	fc 01       	movw	r30, r24
 7f4:	10 82       	st	Z, r1
	EIMSK = (1<<INT0);
 7f6:	8d e3       	ldi	r24, 0x3D	; 61
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	21 e0       	ldi	r18, 0x01	; 1
 7fc:	fc 01       	movw	r30, r24
 7fe:	20 83       	st	Z, r18
}
 800:	df 91       	pop	r29
 802:	cf 91       	pop	r28
 804:	08 95       	ret

00000806 <_ZN8Ptracker7setZeroEv>:

void setZero() {
 806:	cf 93       	push	r28
 808:	df 93       	push	r29
 80a:	cd b7       	in	r28, 0x3d	; 61
 80c:	de b7       	in	r29, 0x3e	; 62
	cli();
 80e:	f8 94       	cli
	xPos = 0;
 810:	10 92 c2 11 	sts	0x11C2, r1
 814:	10 92 c1 11 	sts	0x11C1, r1
	sei();
 818:	78 94       	sei
}
 81a:	df 91       	pop	r29
 81c:	cf 91       	pop	r28
 81e:	08 95       	ret

00000820 <__vector_1>:
	int16_t res = xPos;	// int16_t is not atomic on 8-bit mcu
	sei();
	return res;
}

ISR(INT0_vect) {
 820:	1f 92       	push	r1
 822:	0f 92       	push	r0
 824:	00 90 5f 00 	lds	r0, 0x005F
 828:	0f 92       	push	r0
 82a:	11 24       	eor	r1, r1
 82c:	00 90 5b 00 	lds	r0, 0x005B
 830:	0f 92       	push	r0
 832:	2f 93       	push	r18
 834:	3f 93       	push	r19
 836:	4f 93       	push	r20
 838:	5f 93       	push	r21
 83a:	6f 93       	push	r22
 83c:	7f 93       	push	r23
 83e:	8f 93       	push	r24
 840:	9f 93       	push	r25
 842:	af 93       	push	r26
 844:	bf 93       	push	r27
 846:	ef 93       	push	r30
 848:	ff 93       	push	r31
 84a:	cf 93       	push	r28
 84c:	df 93       	push	r29
 84e:	cd b7       	in	r28, 0x3d	; 61
 850:	de b7       	in	r29, 0x3e	; 62
	if (PTRACKER_ENA_PORT & PTRACKER_ENA_PIN) {
 852:	89 e0       	ldi	r24, 0x09	; 9
 854:	91 e0       	ldi	r25, 0x01	; 1
 856:	fc 01       	movw	r30, r24
 858:	80 81       	ld	r24, Z
 85a:	88 2f       	mov	r24, r24
 85c:	90 e0       	ldi	r25, 0x00	; 0
 85e:	81 70       	andi	r24, 0x01	; 1
 860:	99 27       	eor	r25, r25
 862:	21 e0       	ldi	r18, 0x01	; 1
 864:	00 97       	sbiw	r24, 0x00	; 0
 866:	09 f4       	brne	.+2      	; 0x86a <__vector_1+0x4a>
 868:	20 e0       	ldi	r18, 0x00	; 0
 86a:	22 23       	and	r18, r18
 86c:	09 f4       	brne	.+2      	; 0x870 <__vector_1+0x50>
 86e:	4e c0       	rjmp	.+156    	; 0x90c <__vector_1+0xec>
		if (PTRACKER_DIR_PORT & PTRACKER_DIR_PIN) {
 870:	83 e2       	ldi	r24, 0x23	; 35
 872:	90 e0       	ldi	r25, 0x00	; 0
 874:	fc 01       	movw	r30, r24
 876:	80 81       	ld	r24, Z
 878:	88 2f       	mov	r24, r24
 87a:	90 e0       	ldi	r25, 0x00	; 0
 87c:	81 70       	andi	r24, 0x01	; 1
 87e:	99 27       	eor	r25, r25
 880:	21 e0       	ldi	r18, 0x01	; 1
 882:	00 97       	sbiw	r24, 0x00	; 0
 884:	09 f4       	brne	.+2      	; 0x888 <__vector_1+0x68>
 886:	20 e0       	ldi	r18, 0x00	; 0
 888:	22 23       	and	r18, r18
 88a:	e1 f0       	breq	.+56     	; 0x8c4 <__vector_1+0xa4>
			xPos++;
 88c:	80 91 c1 11 	lds	r24, 0x11C1
 890:	90 91 c2 11 	lds	r25, 0x11C2
 894:	01 96       	adiw	r24, 0x01	; 1
 896:	90 93 c2 11 	sts	0x11C2, r25
 89a:	80 93 c1 11 	sts	0x11C1, r24
			if (!dir) {
 89e:	90 91 c3 11 	lds	r25, 0x11C3
 8a2:	81 e0       	ldi	r24, 0x01	; 1
 8a4:	99 23       	and	r25, r25
 8a6:	09 f0       	breq	.+2      	; 0x8aa <__vector_1+0x8a>
 8a8:	80 e0       	ldi	r24, 0x00	; 0
 8aa:	88 23       	and	r24, r24
 8ac:	39 f0       	breq	.+14     	; 0x8bc <__vector_1+0x9c>
				onDirChangedPtr(1);
 8ae:	20 91 bd 11 	lds	r18, 0x11BD
 8b2:	30 91 be 11 	lds	r19, 0x11BE
 8b6:	81 e0       	ldi	r24, 0x01	; 1
 8b8:	f9 01       	movw	r30, r18
 8ba:	19 95       	eicall
			}
			dir = 1;
 8bc:	81 e0       	ldi	r24, 0x01	; 1
 8be:	80 93 c3 11 	sts	0x11C3, r24
 8c2:	1a c0       	rjmp	.+52     	; 0x8f8 <__vector_1+0xd8>
		}
		else {
			xPos--;
 8c4:	80 91 c1 11 	lds	r24, 0x11C1
 8c8:	90 91 c2 11 	lds	r25, 0x11C2
 8cc:	01 97       	sbiw	r24, 0x01	; 1
 8ce:	90 93 c2 11 	sts	0x11C2, r25
 8d2:	80 93 c1 11 	sts	0x11C1, r24
			if (dir) {
 8d6:	90 91 c3 11 	lds	r25, 0x11C3
 8da:	81 e0       	ldi	r24, 0x01	; 1
 8dc:	99 23       	and	r25, r25
 8de:	09 f4       	brne	.+2      	; 0x8e2 <__vector_1+0xc2>
 8e0:	80 e0       	ldi	r24, 0x00	; 0
 8e2:	88 23       	and	r24, r24
 8e4:	39 f0       	breq	.+14     	; 0x8f4 <__vector_1+0xd4>
				onDirChangedPtr(0);
 8e6:	20 91 bd 11 	lds	r18, 0x11BD
 8ea:	30 91 be 11 	lds	r19, 0x11BE
 8ee:	80 e0       	ldi	r24, 0x00	; 0
 8f0:	f9 01       	movw	r30, r18
 8f2:	19 95       	eicall
			}
			dir = 0;
 8f4:	10 92 c3 11 	sts	0x11C3, r1
		}
		onPositionChangedPtr(xPos);
 8f8:	20 91 bf 11 	lds	r18, 0x11BF
 8fc:	30 91 c0 11 	lds	r19, 0x11C0
 900:	80 91 c1 11 	lds	r24, 0x11C1
 904:	90 91 c2 11 	lds	r25, 0x11C2
 908:	f9 01       	movw	r30, r18
 90a:	19 95       	eicall
	}
}
 90c:	df 91       	pop	r29
 90e:	cf 91       	pop	r28
 910:	ff 91       	pop	r31
 912:	ef 91       	pop	r30
 914:	bf 91       	pop	r27
 916:	af 91       	pop	r26
 918:	9f 91       	pop	r25
 91a:	8f 91       	pop	r24
 91c:	7f 91       	pop	r23
 91e:	6f 91       	pop	r22
 920:	5f 91       	pop	r21
 922:	4f 91       	pop	r20
 924:	3f 91       	pop	r19
 926:	2f 91       	pop	r18
 928:	0f 90       	pop	r0
 92a:	00 92 5b 00 	sts	0x005B, r0
 92e:	0f 90       	pop	r0
 930:	00 92 5f 00 	sts	0x005F, r0
 934:	0f 90       	pop	r0
 936:	1f 90       	pop	r1
 938:	18 95       	reti

0000093a <_ZN6Timer09initTimerEv>:

namespace Timer0 {

FVoid timerHandlers[5] = {0, 0, 0, 0, 0};

void initTimer() {
 93a:	cf 93       	push	r28
 93c:	df 93       	push	r29
 93e:	cd b7       	in	r28, 0x3d	; 61
 940:	de b7       	in	r29, 0x3e	; 62
	TCCR0A = (1<<WGM01);	// Mode2: CTC
 942:	84 e4       	ldi	r24, 0x44	; 68
 944:	90 e0       	ldi	r25, 0x00	; 0
 946:	22 e0       	ldi	r18, 0x02	; 2
 948:	fc 01       	movw	r30, r24
 94a:	20 83       	st	Z, r18
	TCCR0B = (1<<CS01) | (1<<CS00);	// CLKio/64
 94c:	85 e4       	ldi	r24, 0x45	; 69
 94e:	90 e0       	ldi	r25, 0x00	; 0
 950:	23 e0       	ldi	r18, 0x03	; 3
 952:	fc 01       	movw	r30, r24
 954:	20 83       	st	Z, r18
	OCR0A = TIMER0_TOP;
 956:	87 e4       	ldi	r24, 0x47	; 71
 958:	90 e0       	ldi	r25, 0x00	; 0
 95a:	29 ef       	ldi	r18, 0xF9	; 249
 95c:	fc 01       	movw	r30, r24
 95e:	20 83       	st	Z, r18
	TCNT0 = 0;
 960:	86 e4       	ldi	r24, 0x46	; 70
 962:	90 e0       	ldi	r25, 0x00	; 0
 964:	fc 01       	movw	r30, r24
 966:	10 82       	st	Z, r1
	TIMSK0 = (1<<OCIE0A);
 968:	8e e6       	ldi	r24, 0x6E	; 110
 96a:	90 e0       	ldi	r25, 0x00	; 0
 96c:	22 e0       	ldi	r18, 0x02	; 2
 96e:	fc 01       	movw	r30, r24
 970:	20 83       	st	Z, r18
	DDRC |= (1<<PC5);
 972:	87 e2       	ldi	r24, 0x27	; 39
 974:	90 e0       	ldi	r25, 0x00	; 0
 976:	27 e2       	ldi	r18, 0x27	; 39
 978:	30 e0       	ldi	r19, 0x00	; 0
 97a:	f9 01       	movw	r30, r18
 97c:	20 81       	ld	r18, Z
 97e:	20 62       	ori	r18, 0x20	; 32
 980:	fc 01       	movw	r30, r24
 982:	20 83       	st	Z, r18
}
 984:	df 91       	pop	r29
 986:	cf 91       	pop	r28
 988:	08 95       	ret

0000098a <__vector_21>:

ISR(TIMER0_COMPA_vect) {
 98a:	1f 92       	push	r1
 98c:	0f 92       	push	r0
 98e:	00 90 5f 00 	lds	r0, 0x005F
 992:	0f 92       	push	r0
 994:	11 24       	eor	r1, r1
 996:	00 90 5b 00 	lds	r0, 0x005B
 99a:	0f 92       	push	r0
 99c:	2f 93       	push	r18
 99e:	3f 93       	push	r19
 9a0:	4f 93       	push	r20
 9a2:	5f 93       	push	r21
 9a4:	6f 93       	push	r22
 9a6:	7f 93       	push	r23
 9a8:	8f 93       	push	r24
 9aa:	9f 93       	push	r25
 9ac:	af 93       	push	r26
 9ae:	bf 93       	push	r27
 9b0:	ef 93       	push	r30
 9b2:	ff 93       	push	r31
 9b4:	cf 93       	push	r28
 9b6:	df 93       	push	r29
 9b8:	1f 92       	push	r1
 9ba:	cd b7       	in	r28, 0x3d	; 61
 9bc:	de b7       	in	r29, 0x3e	; 62
	uint8_t i = 0;
 9be:	19 82       	std	Y+1, r1	; 0x01
	while (timerHandlers[i] != 0) {
 9c0:	0f c0       	rjmp	.+30     	; 0x9e0 <__vector_21+0x56>
		timerHandlers[i]();
 9c2:	89 81       	ldd	r24, Y+1	; 0x01
 9c4:	88 2f       	mov	r24, r24
 9c6:	90 e0       	ldi	r25, 0x00	; 0
 9c8:	88 0f       	add	r24, r24
 9ca:	99 1f       	adc	r25, r25
 9cc:	8c 53       	subi	r24, 0x3C	; 60
 9ce:	9e 4e       	sbci	r25, 0xEE	; 238
 9d0:	fc 01       	movw	r30, r24
 9d2:	80 81       	ld	r24, Z
 9d4:	91 81       	ldd	r25, Z+1	; 0x01
 9d6:	fc 01       	movw	r30, r24
 9d8:	19 95       	eicall
		i++;
 9da:	89 81       	ldd	r24, Y+1	; 0x01
 9dc:	8f 5f       	subi	r24, 0xFF	; 255
 9de:	89 83       	std	Y+1, r24	; 0x01
	DDRC |= (1<<PC5);
}

ISR(TIMER0_COMPA_vect) {
	uint8_t i = 0;
	while (timerHandlers[i] != 0) {
 9e0:	89 81       	ldd	r24, Y+1	; 0x01
 9e2:	88 2f       	mov	r24, r24
 9e4:	90 e0       	ldi	r25, 0x00	; 0
 9e6:	88 0f       	add	r24, r24
 9e8:	99 1f       	adc	r25, r25
 9ea:	8c 53       	subi	r24, 0x3C	; 60
 9ec:	9e 4e       	sbci	r25, 0xEE	; 238
 9ee:	fc 01       	movw	r30, r24
 9f0:	80 81       	ld	r24, Z
 9f2:	91 81       	ldd	r25, Z+1	; 0x01
 9f4:	00 97       	sbiw	r24, 0x00	; 0
 9f6:	29 f7       	brne	.-54     	; 0x9c2 <__vector_21+0x38>
		timerHandlers[i]();
		i++;
	}
}
 9f8:	0f 90       	pop	r0
 9fa:	df 91       	pop	r29
 9fc:	cf 91       	pop	r28
 9fe:	ff 91       	pop	r31
 a00:	ef 91       	pop	r30
 a02:	bf 91       	pop	r27
 a04:	af 91       	pop	r26
 a06:	9f 91       	pop	r25
 a08:	8f 91       	pop	r24
 a0a:	7f 91       	pop	r23
 a0c:	6f 91       	pop	r22
 a0e:	5f 91       	pop	r21
 a10:	4f 91       	pop	r20
 a12:	3f 91       	pop	r19
 a14:	2f 91       	pop	r18
 a16:	0f 90       	pop	r0
 a18:	00 92 5b 00 	sts	0x005B, r0
 a1c:	0f 90       	pop	r0
 a1e:	00 92 5f 00 	sts	0x005F, r0
 a22:	0f 90       	pop	r0
 a24:	1f 90       	pop	r1
 a26:	18 95       	reti

00000a28 <_ZN6Timer19initTimerEv>:
#include <avr/io.h>
#include <avr/interrupt.h>

namespace Timer1 {

void initTimer() {
 a28:	cf 93       	push	r28
 a2a:	df 93       	push	r29
 a2c:	cd b7       	in	r28, 0x3d	; 61
 a2e:	de b7       	in	r29, 0x3e	; 62
	TCNT1 = 0;
 a30:	84 e8       	ldi	r24, 0x84	; 132
 a32:	90 e0       	ldi	r25, 0x00	; 0
 a34:	fc 01       	movw	r30, r24
 a36:	11 82       	std	Z+1, r1	; 0x01
 a38:	10 82       	st	Z, r1
	OCR1A = -1;
 a3a:	88 e8       	ldi	r24, 0x88	; 136
 a3c:	90 e0       	ldi	r25, 0x00	; 0
 a3e:	2f ef       	ldi	r18, 0xFF	; 255
 a40:	3f ef       	ldi	r19, 0xFF	; 255
 a42:	fc 01       	movw	r30, r24
 a44:	31 83       	std	Z+1, r19	; 0x01
 a46:	20 83       	st	Z, r18
	TCCR1A = (1<<COM1A1) | (1<<WGM11) | (1<<WGM10);
 a48:	80 e8       	ldi	r24, 0x80	; 128
 a4a:	90 e0       	ldi	r25, 0x00	; 0
 a4c:	23 e8       	ldi	r18, 0x83	; 131
 a4e:	fc 01       	movw	r30, r24
 a50:	20 83       	st	Z, r18
	TCCR1B = (1<<WGM13) | (1<<WGM12); // stopped
 a52:	81 e8       	ldi	r24, 0x81	; 129
 a54:	90 e0       	ldi	r25, 0x00	; 0
 a56:	28 e1       	ldi	r18, 0x18	; 24
 a58:	fc 01       	movw	r30, r24
 a5a:	20 83       	st	Z, r18
	TIMSK1 = (1<<TOIE1);
 a5c:	8f e6       	ldi	r24, 0x6F	; 111
 a5e:	90 e0       	ldi	r25, 0x00	; 0
 a60:	21 e0       	ldi	r18, 0x01	; 1
 a62:	fc 01       	movw	r30, r24
 a64:	20 83       	st	Z, r18
	DDRB |= (1<<PB5);
 a66:	84 e2       	ldi	r24, 0x24	; 36
 a68:	90 e0       	ldi	r25, 0x00	; 0
 a6a:	24 e2       	ldi	r18, 0x24	; 36
 a6c:	30 e0       	ldi	r19, 0x00	; 0
 a6e:	f9 01       	movw	r30, r18
 a70:	20 81       	ld	r18, Z
 a72:	20 62       	ori	r18, 0x20	; 32
 a74:	fc 01       	movw	r30, r24
 a76:	20 83       	st	Z, r18
}
 a78:	df 91       	pop	r29
 a7a:	cf 91       	pop	r28
 a7c:	08 95       	ret

00000a7e <_ZN6Timer116setPulseDurationEi>:
void setPulseDuration(int16_t duration) {
 a7e:	cf 93       	push	r28
 a80:	df 93       	push	r29
 a82:	1f 92       	push	r1
 a84:	1f 92       	push	r1
 a86:	cd b7       	in	r28, 0x3d	; 61
 a88:	de b7       	in	r29, 0x3e	; 62
 a8a:	9a 83       	std	Y+2, r25	; 0x02
 a8c:	89 83       	std	Y+1, r24	; 0x01
	OCR1A = duration;
 a8e:	88 e8       	ldi	r24, 0x88	; 136
 a90:	90 e0       	ldi	r25, 0x00	; 0
 a92:	29 81       	ldd	r18, Y+1	; 0x01
 a94:	3a 81       	ldd	r19, Y+2	; 0x02
 a96:	fc 01       	movw	r30, r24
 a98:	31 83       	std	Z+1, r19	; 0x01
 a9a:	20 83       	st	Z, r18
}
 a9c:	0f 90       	pop	r0
 a9e:	0f 90       	pop	r0
 aa0:	df 91       	pop	r29
 aa2:	cf 91       	pop	r28
 aa4:	08 95       	ret

00000aa6 <_ZN6Timer15pulseEv>:
void pulse() {
 aa6:	cf 93       	push	r28
 aa8:	df 93       	push	r29
 aaa:	cd b7       	in	r28, 0x3d	; 61
 aac:	de b7       	in	r29, 0x3e	; 62
	TCNT1 = 0;
 aae:	84 e8       	ldi	r24, 0x84	; 132
 ab0:	90 e0       	ldi	r25, 0x00	; 0
 ab2:	fc 01       	movw	r30, r24
 ab4:	11 82       	std	Z+1, r1	; 0x01
 ab6:	10 82       	st	Z, r1
	TCCR1B |= (1<<CS11);
 ab8:	81 e8       	ldi	r24, 0x81	; 129
 aba:	90 e0       	ldi	r25, 0x00	; 0
 abc:	21 e8       	ldi	r18, 0x81	; 129
 abe:	30 e0       	ldi	r19, 0x00	; 0
 ac0:	f9 01       	movw	r30, r18
 ac2:	20 81       	ld	r18, Z
 ac4:	22 60       	ori	r18, 0x02	; 2
 ac6:	fc 01       	movw	r30, r24
 ac8:	20 83       	st	Z, r18
}
 aca:	df 91       	pop	r29
 acc:	cf 91       	pop	r28
 ace:	08 95       	ret

00000ad0 <__vector_20>:

ISR(TIMER1_OVF_vect) {
 ad0:	1f 92       	push	r1
 ad2:	0f 92       	push	r0
 ad4:	00 90 5f 00 	lds	r0, 0x005F
 ad8:	0f 92       	push	r0
 ada:	11 24       	eor	r1, r1
 adc:	00 90 5b 00 	lds	r0, 0x005B
 ae0:	0f 92       	push	r0
 ae2:	2f 93       	push	r18
 ae4:	3f 93       	push	r19
 ae6:	8f 93       	push	r24
 ae8:	9f 93       	push	r25
 aea:	ef 93       	push	r30
 aec:	ff 93       	push	r31
 aee:	cf 93       	push	r28
 af0:	df 93       	push	r29
 af2:	cd b7       	in	r28, 0x3d	; 61
 af4:	de b7       	in	r29, 0x3e	; 62
	TCCR1B &= ~(1<<CS11);
 af6:	81 e8       	ldi	r24, 0x81	; 129
 af8:	90 e0       	ldi	r25, 0x00	; 0
 afa:	21 e8       	ldi	r18, 0x81	; 129
 afc:	30 e0       	ldi	r19, 0x00	; 0
 afe:	f9 01       	movw	r30, r18
 b00:	20 81       	ld	r18, Z
 b02:	2d 7f       	andi	r18, 0xFD	; 253
 b04:	fc 01       	movw	r30, r24
 b06:	20 83       	st	Z, r18
}
 b08:	df 91       	pop	r29
 b0a:	cf 91       	pop	r28
 b0c:	ff 91       	pop	r31
 b0e:	ef 91       	pop	r30
 b10:	9f 91       	pop	r25
 b12:	8f 91       	pop	r24
 b14:	3f 91       	pop	r19
 b16:	2f 91       	pop	r18
 b18:	0f 90       	pop	r0
 b1a:	00 92 5b 00 	sts	0x005B, r0
 b1e:	0f 90       	pop	r0
 b20:	00 92 5f 00 	sts	0x005F, r0
 b24:	0f 90       	pop	r0
 b26:	1f 90       	pop	r1
 b28:	18 95       	reti

00000b2a <_ZN6Usart09initUsartEv>:
volatile static const uint8_t *txPtr;
volatile static int8_t txBytesLeft;
volatile static uint8_t timer;
static uint8_t rdIdx;

void initUsart() {
 b2a:	cf 93       	push	r28
 b2c:	df 93       	push	r29
 b2e:	cd b7       	in	r28, 0x3d	; 61
 b30:	de b7       	in	r29, 0x3e	; 62
	rxIdx = 0;
 b32:	10 92 ce 11 	sts	0x11CE, r1
	rdIdx = 0;
 b36:	10 92 f3 11 	sts	0x11F3, r1
	txBytesLeft = 0;
 b3a:	10 92 f1 11 	sts	0x11F1, r1
	memset((void*)rxBuff, 0, USART0_RX_BUFF_SIZE);
 b3e:	40 e2       	ldi	r20, 0x20	; 32
 b40:	50 e0       	ldi	r21, 0x00	; 0
 b42:	60 e0       	ldi	r22, 0x00	; 0
 b44:	70 e0       	ldi	r23, 0x00	; 0
 b46:	8f ec       	ldi	r24, 0xCF	; 207
 b48:	91 e1       	ldi	r25, 0x11	; 17
 b4a:	6f d1       	rcall	.+734    	; 0xe2a <memset>
 b4c:	80 ec       	ldi	r24, 0xC0	; 192
	UCSR0A = (1<<U2X0);	// U2X0 = 1
 b4e:	90 e0       	ldi	r25, 0x00	; 0
 b50:	22 e0       	ldi	r18, 0x02	; 2
 b52:	fc 01       	movw	r30, r24
 b54:	20 83       	st	Z, r18
 b56:	81 ec       	ldi	r24, 0xC1	; 193
	UCSR0B = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0) | (1<<UDRIE0);
 b58:	90 e0       	ldi	r25, 0x00	; 0
 b5a:	28 eb       	ldi	r18, 0xB8	; 184
 b5c:	fc 01       	movw	r30, r24
 b5e:	20 83       	st	Z, r18
 b60:	82 ec       	ldi	r24, 0xC2	; 194
	UCSR0C = (1<<UCSZ01) | (1<<UCSZ00);	// 8N1
 b62:	90 e0       	ldi	r25, 0x00	; 0
 b64:	26 e0       	ldi	r18, 0x06	; 6
 b66:	fc 01       	movw	r30, r24
 b68:	20 83       	st	Z, r18
 b6a:	85 ec       	ldi	r24, 0xC5	; 197
	UBRR0H = 0;
 b6c:	90 e0       	ldi	r25, 0x00	; 0
 b6e:	fc 01       	movw	r30, r24
 b70:	10 82       	st	Z, r1
 b72:	84 ec       	ldi	r24, 0xC4	; 196
	UBRR0L = 16;	// 11500kBps@16MHz
 b74:	90 e0       	ldi	r25, 0x00	; 0
 b76:	20 e1       	ldi	r18, 0x10	; 16
 b78:	fc 01       	movw	r30, r24
 b7a:	20 83       	st	Z, r18
 b7c:	8d e2       	ldi	r24, 0x2D	; 45
	DDRE |= (1<<PE1);
 b7e:	90 e0       	ldi	r25, 0x00	; 0
 b80:	2d e2       	ldi	r18, 0x2D	; 45
 b82:	30 e0       	ldi	r19, 0x00	; 0
 b84:	f9 01       	movw	r30, r18
 b86:	20 81       	ld	r18, Z
 b88:	22 60       	ori	r18, 0x02	; 2
 b8a:	fc 01       	movw	r30, r24
 b8c:	20 83       	st	Z, r18
 b8e:	df 91       	pop	r29
}
 b90:	cf 91       	pop	r28
 b92:	08 95       	ret

00000b94 <_ZN6Usart09availableEv>:

uint8_t available() {
 b94:	cf 93       	push	r28
 b96:	df 93       	push	r29
 b98:	cd b7       	in	r28, 0x3d	; 61
 b9a:	de b7       	in	r29, 0x3e	; 62
	return rdIdx != rxIdx;
 b9c:	20 91 f3 11 	lds	r18, 0x11F3
 ba0:	90 91 ce 11 	lds	r25, 0x11CE
 ba4:	81 e0       	ldi	r24, 0x01	; 1
 ba6:	29 17       	cp	r18, r25
 ba8:	09 f4       	brne	.+2      	; 0xbac <_ZN6Usart09availableEv+0x18>
 baa:	80 e0       	ldi	r24, 0x00	; 0
}
 bac:	df 91       	pop	r29
 bae:	cf 91       	pop	r28
 bb0:	08 95       	ret

00000bb2 <_ZN6Usart04peekEv>:

uint8_t peek() {
 bb2:	cf 93       	push	r28
 bb4:	df 93       	push	r29
 bb6:	cd b7       	in	r28, 0x3d	; 61
 bb8:	de b7       	in	r29, 0x3e	; 62
	while(rdIdx == rxIdx);
 bba:	00 00       	nop
 bbc:	20 91 f3 11 	lds	r18, 0x11F3
 bc0:	90 91 ce 11 	lds	r25, 0x11CE
 bc4:	81 e0       	ldi	r24, 0x01	; 1
 bc6:	29 17       	cp	r18, r25
 bc8:	09 f0       	breq	.+2      	; 0xbcc <_ZN6Usart04peekEv+0x1a>
 bca:	80 e0       	ldi	r24, 0x00	; 0
 bcc:	88 23       	and	r24, r24
 bce:	b1 f7       	brne	.-20     	; 0xbbc <_ZN6Usart04peekEv+0xa>
	return rxBuff[rdIdx];
 bd0:	80 91 f3 11 	lds	r24, 0x11F3
 bd4:	88 2f       	mov	r24, r24
 bd6:	90 e0       	ldi	r25, 0x00	; 0
 bd8:	81 53       	subi	r24, 0x31	; 49
 bda:	9e 4e       	sbci	r25, 0xEE	; 238
 bdc:	fc 01       	movw	r30, r24
 bde:	80 81       	ld	r24, Z
}
 be0:	df 91       	pop	r29
 be2:	cf 91       	pop	r28
 be4:	08 95       	ret

00000be6 <_ZN6Usart04readEv>:

uint8_t read() {
 be6:	cf 93       	push	r28
 be8:	df 93       	push	r29
 bea:	1f 92       	push	r1
 bec:	cd b7       	in	r28, 0x3d	; 61
 bee:	de b7       	in	r29, 0x3e	; 62
	while(rdIdx == rxIdx);
 bf0:	00 00       	nop
 bf2:	20 91 f3 11 	lds	r18, 0x11F3
 bf6:	90 91 ce 11 	lds	r25, 0x11CE
 bfa:	81 e0       	ldi	r24, 0x01	; 1
 bfc:	29 17       	cp	r18, r25
 bfe:	09 f0       	breq	.+2      	; 0xc02 <_ZN6Usart04readEv+0x1c>
 c00:	80 e0       	ldi	r24, 0x00	; 0
 c02:	88 23       	and	r24, r24
 c04:	b1 f7       	brne	.-20     	; 0xbf2 <_ZN6Usart04readEv+0xc>
	uint8_t res = rxBuff[rdIdx];
 c06:	80 91 f3 11 	lds	r24, 0x11F3
 c0a:	88 2f       	mov	r24, r24
 c0c:	90 e0       	ldi	r25, 0x00	; 0
 c0e:	81 53       	subi	r24, 0x31	; 49
 c10:	9e 4e       	sbci	r25, 0xEE	; 238
 c12:	fc 01       	movw	r30, r24
 c14:	80 81       	ld	r24, Z
 c16:	89 83       	std	Y+1, r24	; 0x01
	rdIdx = (rdIdx + 1) & USART0_BITMASK;
 c18:	80 91 f3 11 	lds	r24, 0x11F3
 c1c:	8f 5f       	subi	r24, 0xFF	; 255
 c1e:	8f 71       	andi	r24, 0x1F	; 31
 c20:	80 93 f3 11 	sts	0x11F3, r24
	return res;
 c24:	89 81       	ldd	r24, Y+1	; 0x01
}
 c26:	0f 90       	pop	r0
 c28:	df 91       	pop	r29
 c2a:	cf 91       	pop	r28
 c2c:	08 95       	ret

00000c2e <_ZN6Usart09readBytesEPhj>:

uint8_t readBytes(uint8_t *ptr, uint16_t cnt) {
 c2e:	cf 93       	push	r28
 c30:	df 93       	push	r29
 c32:	00 d0       	rcall	.+0      	; 0xc34 <_ZN6Usart09readBytesEPhj+0x6>
 c34:	00 d0       	rcall	.+0      	; 0xc36 <_ZN6Usart09readBytesEPhj+0x8>
 c36:	cd b7       	in	r28, 0x3d	; 61
 c38:	de b7       	in	r29, 0x3e	; 62
 c3a:	9c 83       	std	Y+4, r25	; 0x04
 c3c:	8b 83       	std	Y+3, r24	; 0x03
 c3e:	7e 83       	std	Y+6, r23	; 0x06
 c40:	6d 83       	std	Y+5, r22	; 0x05
	uint16_t ctr = 0;
 c42:	1a 82       	std	Y+2, r1	; 0x02
 c44:	19 82       	std	Y+1, r1	; 0x01
	timer = 0;
 c46:	10 92 f2 11 	sts	0x11F2, r1
	while(ctr < cnt) {
 c4a:	32 c0       	rjmp	.+100    	; 0xcb0 <_ZN6Usart09readBytesEPhj+0x82>
		while(rdIdx != rxIdx) {
 c4c:	1e c0       	rjmp	.+60     	; 0xc8a <_ZN6Usart09readBytesEPhj+0x5c>
			*ptr++ = rxBuff[rdIdx];
 c4e:	8b 81       	ldd	r24, Y+3	; 0x03
 c50:	9c 81       	ldd	r25, Y+4	; 0x04
 c52:	9c 01       	movw	r18, r24
 c54:	2f 5f       	subi	r18, 0xFF	; 255
 c56:	3f 4f       	sbci	r19, 0xFF	; 255
 c58:	3c 83       	std	Y+4, r19	; 0x04
 c5a:	2b 83       	std	Y+3, r18	; 0x03
 c5c:	20 91 f3 11 	lds	r18, 0x11F3
 c60:	22 2f       	mov	r18, r18
 c62:	30 e0       	ldi	r19, 0x00	; 0
 c64:	21 53       	subi	r18, 0x31	; 49
 c66:	3e 4e       	sbci	r19, 0xEE	; 238
 c68:	f9 01       	movw	r30, r18
 c6a:	20 81       	ld	r18, Z
 c6c:	fc 01       	movw	r30, r24
 c6e:	20 83       	st	Z, r18
			rdIdx = (rdIdx + 1) & USART0_BITMASK;
 c70:	80 91 f3 11 	lds	r24, 0x11F3
 c74:	8f 5f       	subi	r24, 0xFF	; 255
 c76:	8f 71       	andi	r24, 0x1F	; 31
 c78:	80 93 f3 11 	sts	0x11F3, r24
			ctr++;
 c7c:	89 81       	ldd	r24, Y+1	; 0x01
 c7e:	9a 81       	ldd	r25, Y+2	; 0x02
 c80:	01 96       	adiw	r24, 0x01	; 1
 c82:	9a 83       	std	Y+2, r25	; 0x02
 c84:	89 83       	std	Y+1, r24	; 0x01
			timer = 0;
 c86:	10 92 f2 11 	sts	0x11F2, r1

uint8_t readBytes(uint8_t *ptr, uint16_t cnt) {
	uint16_t ctr = 0;
	timer = 0;
	while(ctr < cnt) {
		while(rdIdx != rxIdx) {
 c8a:	20 91 f3 11 	lds	r18, 0x11F3
 c8e:	90 91 ce 11 	lds	r25, 0x11CE
 c92:	81 e0       	ldi	r24, 0x01	; 1
 c94:	29 17       	cp	r18, r25
 c96:	09 f4       	brne	.+2      	; 0xc9a <_ZN6Usart09readBytesEPhj+0x6c>
 c98:	80 e0       	ldi	r24, 0x00	; 0
 c9a:	88 23       	and	r24, r24
 c9c:	c1 f6       	brne	.-80     	; 0xc4e <_ZN6Usart09readBytesEPhj+0x20>
			*ptr++ = rxBuff[rdIdx];
			rdIdx = (rdIdx + 1) & USART0_BITMASK;
			ctr++;
			timer = 0;
		}
		if (timer >= USART0_RX_TIMEOUT) {
 c9e:	90 91 f2 11 	lds	r25, 0x11F2
 ca2:	81 e0       	ldi	r24, 0x01	; 1
 ca4:	94 36       	cpi	r25, 0x64	; 100
 ca6:	08 f4       	brcc	.+2      	; 0xcaa <_ZN6Usart09readBytesEPhj+0x7c>
 ca8:	80 e0       	ldi	r24, 0x00	; 0
 caa:	88 23       	and	r24, r24
 cac:	09 f0       	breq	.+2      	; 0xcb0 <_ZN6Usart09readBytesEPhj+0x82>
			break;
 cae:	07 c0       	rjmp	.+14     	; 0xcbe <_ZN6Usart09readBytesEPhj+0x90>
}

uint8_t readBytes(uint8_t *ptr, uint16_t cnt) {
	uint16_t ctr = 0;
	timer = 0;
	while(ctr < cnt) {
 cb0:	29 81       	ldd	r18, Y+1	; 0x01
 cb2:	3a 81       	ldd	r19, Y+2	; 0x02
 cb4:	8d 81       	ldd	r24, Y+5	; 0x05
 cb6:	9e 81       	ldd	r25, Y+6	; 0x06
 cb8:	28 17       	cp	r18, r24
 cba:	39 07       	cpc	r19, r25
 cbc:	38 f2       	brcs	.-114    	; 0xc4c <_ZN6Usart09readBytesEPhj+0x1e>
		}
		if (timer >= USART0_RX_TIMEOUT) {
			break;
		}
	}
	return ctr;
 cbe:	89 81       	ldd	r24, Y+1	; 0x01
}
 cc0:	26 96       	adiw	r28, 0x06	; 6
 cc2:	0f b6       	in	r0, 0x3f	; 63
 cc4:	f8 94       	cli
 cc6:	de bf       	out	0x3e, r29	; 62
 cc8:	0f be       	out	0x3f, r0	; 63
 cca:	cd bf       	out	0x3d, r28	; 61
 ccc:	df 91       	pop	r29
 cce:	cf 91       	pop	r28
 cd0:	08 95       	ret

00000cd2 <_ZN6Usart05writeEPKhh>:

void write(const uint8_t *ptr, uint8_t cnt) {
 cd2:	cf 93       	push	r28
 cd4:	df 93       	push	r29
 cd6:	00 d0       	rcall	.+0      	; 0xcd8 <_ZN6Usart05writeEPKhh+0x6>
 cd8:	cd b7       	in	r28, 0x3d	; 61
 cda:	de b7       	in	r29, 0x3e	; 62
 cdc:	9a 83       	std	Y+2, r25	; 0x02
 cde:	89 83       	std	Y+1, r24	; 0x01
 ce0:	6b 83       	std	Y+3, r22	; 0x03
	if (!cnt) {
 ce2:	8b 81       	ldd	r24, Y+3	; 0x03
 ce4:	88 23       	and	r24, r24
 ce6:	09 f4       	brne	.+2      	; 0xcea <_ZN6Usart05writeEPKhh+0x18>
		return;
 ce8:	12 c0       	rjmp	.+36     	; 0xd0e <_ZN6Usart05writeEPKhh+0x3c>
	}
	while (txBytesLeft != 0); // Wait while transmission completes
 cea:	00 00       	nop
 cec:	90 91 f1 11 	lds	r25, 0x11F1
 cf0:	81 e0       	ldi	r24, 0x01	; 1
 cf2:	99 23       	and	r25, r25
 cf4:	09 f4       	brne	.+2      	; 0xcf8 <_ZN6Usart05writeEPKhh+0x26>
 cf6:	80 e0       	ldi	r24, 0x00	; 0
 cf8:	88 23       	and	r24, r24
 cfa:	c1 f7       	brne	.-16     	; 0xcec <_ZN6Usart05writeEPKhh+0x1a>
	txPtr = ptr;
 cfc:	89 81       	ldd	r24, Y+1	; 0x01
 cfe:	9a 81       	ldd	r25, Y+2	; 0x02
 d00:	90 93 f0 11 	sts	0x11F0, r25
 d04:	80 93 ef 11 	sts	0x11EF, r24
	txBytesLeft = cnt;
 d08:	8b 81       	ldd	r24, Y+3	; 0x03
 d0a:	80 93 f1 11 	sts	0x11F1, r24
}
 d0e:	0f 90       	pop	r0
 d10:	0f 90       	pop	r0
 d12:	0f 90       	pop	r0
 d14:	df 91       	pop	r29
 d16:	cf 91       	pop	r28
 d18:	08 95       	ret

00000d1a <__vector_25>:

uint8_t isTxBusy() {
	return txBytesLeft != 0;
}

ISR(USART0_RX_vect) {
 d1a:	1f 92       	push	r1
 d1c:	0f 92       	push	r0
 d1e:	00 90 5f 00 	lds	r0, 0x005F
 d22:	0f 92       	push	r0
 d24:	11 24       	eor	r1, r1
 d26:	00 90 5b 00 	lds	r0, 0x005B
 d2a:	0f 92       	push	r0
 d2c:	2f 93       	push	r18
 d2e:	3f 93       	push	r19
 d30:	8f 93       	push	r24
 d32:	9f 93       	push	r25
 d34:	ef 93       	push	r30
 d36:	ff 93       	push	r31
 d38:	cf 93       	push	r28
 d3a:	df 93       	push	r29
 d3c:	cd b7       	in	r28, 0x3d	; 61
 d3e:	de b7       	in	r29, 0x3e	; 62
	rxBuff[rxIdx] = UDR0;
 d40:	80 91 ce 11 	lds	r24, 0x11CE
 d44:	88 2f       	mov	r24, r24
 d46:	90 e0       	ldi	r25, 0x00	; 0
 d48:	26 ec       	ldi	r18, 0xC6	; 198
 d4a:	30 e0       	ldi	r19, 0x00	; 0
 d4c:	f9 01       	movw	r30, r18
 d4e:	20 81       	ld	r18, Z
 d50:	81 53       	subi	r24, 0x31	; 49
 d52:	9e 4e       	sbci	r25, 0xEE	; 238
 d54:	fc 01       	movw	r30, r24
 d56:	20 83       	st	Z, r18
	rxIdx = (rxIdx + 1) & USART0_BITMASK;	// No overrun detection needed yet
 d58:	80 91 ce 11 	lds	r24, 0x11CE
 d5c:	8f 5f       	subi	r24, 0xFF	; 255
 d5e:	8f 71       	andi	r24, 0x1F	; 31
 d60:	80 93 ce 11 	sts	0x11CE, r24
}
 d64:	df 91       	pop	r29
 d66:	cf 91       	pop	r28
 d68:	ff 91       	pop	r31
 d6a:	ef 91       	pop	r30
 d6c:	9f 91       	pop	r25
 d6e:	8f 91       	pop	r24
 d70:	3f 91       	pop	r19
 d72:	2f 91       	pop	r18
 d74:	0f 90       	pop	r0
 d76:	00 92 5b 00 	sts	0x005B, r0
 d7a:	0f 90       	pop	r0
 d7c:	00 92 5f 00 	sts	0x005F, r0
 d80:	0f 90       	pop	r0
 d82:	1f 90       	pop	r1
 d84:	18 95       	reti

00000d86 <__vector_26>:

ISR(USART0_UDRE_vect) {
 d86:	1f 92       	push	r1
 d88:	0f 92       	push	r0
 d8a:	00 90 5f 00 	lds	r0, 0x005F
 d8e:	0f 92       	push	r0
 d90:	11 24       	eor	r1, r1
 d92:	00 90 5b 00 	lds	r0, 0x005B
 d96:	0f 92       	push	r0
 d98:	2f 93       	push	r18
 d9a:	3f 93       	push	r19
 d9c:	4f 93       	push	r20
 d9e:	5f 93       	push	r21
 da0:	8f 93       	push	r24
 da2:	9f 93       	push	r25
 da4:	ef 93       	push	r30
 da6:	ff 93       	push	r31
 da8:	cf 93       	push	r28
 daa:	df 93       	push	r29
 dac:	cd b7       	in	r28, 0x3d	; 61
 dae:	de b7       	in	r29, 0x3e	; 62
	if (txBytesLeft > 0) {
 db0:	90 91 f1 11 	lds	r25, 0x11F1
 db4:	81 e0       	ldi	r24, 0x01	; 1
 db6:	19 16       	cp	r1, r25
 db8:	0c f0       	brlt	.+2      	; 0xdbc <__vector_26+0x36>
 dba:	80 e0       	ldi	r24, 0x00	; 0
 dbc:	88 23       	and	r24, r24
 dbe:	b1 f0       	breq	.+44     	; 0xdec <__vector_26+0x66>
		UDR0 = *txPtr++;
 dc0:	26 ec       	ldi	r18, 0xC6	; 198
 dc2:	30 e0       	ldi	r19, 0x00	; 0
 dc4:	80 91 ef 11 	lds	r24, 0x11EF
 dc8:	90 91 f0 11 	lds	r25, 0x11F0
 dcc:	ac 01       	movw	r20, r24
 dce:	4f 5f       	subi	r20, 0xFF	; 255
 dd0:	5f 4f       	sbci	r21, 0xFF	; 255
 dd2:	50 93 f0 11 	sts	0x11F0, r21
 dd6:	40 93 ef 11 	sts	0x11EF, r20
 dda:	fc 01       	movw	r30, r24
 ddc:	80 81       	ld	r24, Z
 dde:	f9 01       	movw	r30, r18
 de0:	80 83       	st	Z, r24
		txBytesLeft--;
 de2:	80 91 f1 11 	lds	r24, 0x11F1
 de6:	81 50       	subi	r24, 0x01	; 1
 de8:	80 93 f1 11 	sts	0x11F1, r24
	}
}
 dec:	df 91       	pop	r29
 dee:	cf 91       	pop	r28
 df0:	ff 91       	pop	r31
 df2:	ef 91       	pop	r30
 df4:	9f 91       	pop	r25
 df6:	8f 91       	pop	r24
 df8:	5f 91       	pop	r21
 dfa:	4f 91       	pop	r20
 dfc:	3f 91       	pop	r19
 dfe:	2f 91       	pop	r18
 e00:	0f 90       	pop	r0
 e02:	00 92 5b 00 	sts	0x005B, r0
 e06:	0f 90       	pop	r0
 e08:	00 92 5f 00 	sts	0x005F, r0
 e0c:	0f 90       	pop	r0
 e0e:	1f 90       	pop	r1
 e10:	18 95       	reti

00000e12 <_ZN6Usart011onTimerTickEv>:

void disableUsart() {
	UCSR0B = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0) | (1<<UDRIE0);
}

void onTimerTick() {
 e12:	cf 93       	push	r28
 e14:	df 93       	push	r29
 e16:	cd b7       	in	r28, 0x3d	; 61
 e18:	de b7       	in	r29, 0x3e	; 62
	timer++;
 e1a:	80 91 f2 11 	lds	r24, 0x11F2
 e1e:	8f 5f       	subi	r24, 0xFF	; 255
 e20:	80 93 f2 11 	sts	0x11F2, r24
}
 e24:	df 91       	pop	r29
 e26:	cf 91       	pop	r28
 e28:	08 95       	ret

00000e2a <memset>:
 e2a:	dc 01       	movw	r26, r24
 e2c:	01 c0       	rjmp	.+2      	; 0xe30 <memset+0x6>
 e2e:	6d 93       	st	X+, r22
 e30:	41 50       	subi	r20, 0x01	; 1
 e32:	50 40       	sbci	r21, 0x00	; 0
 e34:	e0 f7       	brcc	.-8      	; 0xe2e <memset+0x4>
 e36:	08 95       	ret

00000e38 <_exit>:
 e38:	f8 94       	cli

00000e3a <__stop_program>:
 e3a:	ff cf       	rjmp	.-2      	; 0xe3a <__stop_program>
